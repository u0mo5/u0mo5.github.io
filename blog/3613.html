<!DOCTYPE html>
<html lang="zh_cn">
<head>

        <title>linux编译C</title>
        <meta charset="utf-8" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="/blog/theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="/blog/theme/style.css" />
        <link rel="stylesheet" type="text/css" href="/blog/theme/pygment.css" />

        <script src="/blog/theme/js/libs/modernizr-2.6.2.min.js"></script>




</head>

<body id="index" class="home">


    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="/blog/">逍遥の博客 <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>
             
              <ul class="columns">
                <li><a href="/blog/">首页</a></li>


              </ul>

            </div>

<section id="content" class="body">

   <div class="row">
        <div class="eleven columns">


            <header>
              <h2 class="entry-title">
                <a href="/blog/3613.html" rel="bookmark"
                   title="Permalink to linux编译C">linux编译C</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="1970-01-01T00:00:00+08:00">
                周四 01 一月 1970
              </abbr>
              <address class="vcard author">By 
                <a class="url fn" href="/blog/author/u0mo5.html"> u0mo5</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <ol>
<li>编译单个源文件 为了进行测试，你可以创建"Hello World"程序： #include #include int main(int argc, char <strong>argv) { printf("Hello world!n"); exit(0); } 使用如下命令编译并测试这个代码： # gcc -o hello hello.c # ./hello Hello wordl! 在默认情况下产生的可执行程序名为a.out，但你通常可以通过 gcc 的"-o"选项来指定自己的可执行程序名称。 2. 编译多个源文件 源文件message.c包含一个简单的消息打印函数： #include void goodbye_world(void) { printf("Goodbye, world!n"); } 使用gcc的"-c"标记来编译支持库代码： # gcc -c message.c 这一过程的输出结果是一个名为message.o的文件，它包含适合连接到一个较大程序的已编译目标代码。 创建一个简单的示例程序，它包含一个调用goodbye_world的main函数 #include void goodbye_world(void): int main(int argc, char </strong>argv) { goodbye_world(); exit(0); } 使用GCC编译这个程序： # gcc -c main.c 现在有了两个目标文件： message.o 和 main.o 。它们包含能够被 Linux 执行的目标代码。要从这个目标代码创建Linux可执行程序，需要再一次调用 GCC 来执行连接阶段的工作： # gcc -o goodbye message.o main.o 运行编译结果： # ./goodbye Goodbye, world! 前面这些单独的步骤也可以简化为一个命令，这是因为 GCC 对如何将多个源文件编译为一个可执行程序有内置的规则。 # gcc -o goodbye message.c main.c # ./goodbye Goodbye, world! 3. 使用外部函数库 GCC 常常与包含标准例程的外部软件库结合使用，几乎每一个 Linux 应用程序都依赖于由 GNU C 函数库 GLIBC。 应用外部函数库的例子： #include #include #include #define MAX_INPUT 25 int main(int agrc, char **argv) { char input[MAX_INPUT]; double angle; printf("Give me an angle (in radians) ==&gt;"); if(!fgets(input, MAX_INPUT, stdin)){ perror("an error occurred.n"); } angle = strtod(input, NULL); printf("sin(%e) = %en", angle, sin(angle)); return 0; } 编译命令： # gcc -o trig -lm trig.c GCC 的"-lm"选项，它告诉 GCC 查看系统提供的数学库（libm）。因为Linux和UNIX的系统函数库通常以"lib"为前缀，所以我们假设它存在。真正的函数库位置随系统的不同而 不同，但它一般会位于目录/lib或/usr/lib中，在这些目录中还有数以百计的其他必需的系统函数库。 4. 共享函数库与静态函数库 Linux系统上的函数库分为两种不同的类型：共享的和静态的 静态函数库：每次当应用程序和静态连接的函数库一起编译时，任何引用的库函数中的代码都会被直接包含进最终的二进制程序。 共享函数库：包含每个库函数的单一全局版本，它在所有应用程序之间共享。这一过程背后所涉及的机制相当复杂，但主要依靠的是现代计算机的虚拟内存能力，它允许包含库函数的物理内存安全地在多个独立用户程序之间共享。 使用共享函数库不仅减少了文件的容量和 Linux 应用程序在内存中覆盖的区域，而且它还提高了系统的安全性。一个被许多不同程序同时调用的共享函数库很可能会驻留在内存中，以在需要使用它时被立即使用， 而不是位于磁盘的交换分区中。这有助于进一步减少一些大型 Linux 应用程序的装载时间。 将上面的 message.c 作为共享库函数使用的例子： # gcc -fPIC -c message.c "PIC"命令行标记告诉 GCC 产生的代码不要包含对函数和变量具体内存位置的引用，这是因为现在还无法知道使用该消息代码的应用程序会将它连接到哪一段内存地址空间。这样编译输出的文 件 message.o 可以被用于建立共享函数库，我们只需使用gcc的"-shared"标记即可： # gcc -shared -o libmessage.so message.o 将上面的mian.c使用共享库函数ligmessage.so编译： # gcc -o goodbye -lmessage -L. message.o "-lmessage"标记来告诉 GCC 在连接阶段引用共享函数库 libmessage.so 。"-L."标记告诉 GCC 函数库可能位于当前目录中，否则 GNU 的连接器会查找标准系统函数库目录，在本例的情况下，就找不到可用的函数库了。 此时运行编译好的goodbye会提示找不到共享函数库： #./goodbye ./goodbye: error while loading shared libraries: libmessage.so: cannot open shared object file: No such file or directory 可以使用命令 ldd 来发现一个特定应用程序需要使用的函数库。ldd搜索标准系统函数库路径并显示一个特定程序使用的函数库版本。 #ldd goodbye linux-gate.so.1 =&gt; (0×00493000) libmessage.so =&gt; not found libc.so.6 =&gt; /lib/libc.so.6 (0×0097c000) /lib/ld-linux.so.2 (0×0095a000) 库文件 libmessage.so 不能在任何一个标准搜索路径中找到，而且系统提供的配置文件 /etc/ld.so.conf 也没有包含一个额外的条目来指定包含该库文件的目录。 需要设置一个环境变量LD_LIBRARY_PATH来制定额外的共享函数库搜索路径， # export LD_LIBRARY_PATH=<code>pwd</code> # ldd goodbye linux-gate.so.1 =&gt; (0x002ce000) libmessage.so =&gt; /tmp/cpro/libmessage.so (0x00b0f000) libc.so.6 =&gt; /lib/libc.so.6 (0x0097c000) /lib/ld-linux.so.2 (0x0095a000) 运行程序 # ./goodbye Goodbye, world! gcc在命令行上经常使用的几个选项是： -c 只预处理、编译和汇编源程序，不进行连接。编译器对每一个源程序产生一个目标文件。 -o file 确定输出文件为file。如果没有用-o选项，缺省的可执行文件的输出是 a.out，目标文件和汇编文件的输出对source.suffix分别是source.o和source.s，预处理的C源程序的输出是标准输出stdout。 -Dmacro或-Dmacro=defn 其作用类似于源程序里的#define。例如：% gcc -c -DHAVE_GDBM -DHELP_FILE="help" cdict.c其中第一个- D选项定义宏HAVE_GDBM，在程序里可以用#ifdef去检查它是否被设置。第二个-D选项将宏HELP_FILE定义为字符串"help"（由于 反斜线的作用，引号实际上已成为该宏定义的一部分），这对于控制程序打开哪个文件是很有用的。 -Umacro 某些宏是被编译程序自动定义的。这些宏通常可以指定在其中进行编译的计算机系统类型的符号，用户可以在编译某程序时加上 -v选项以查看gcc缺省定义了哪些宏。如果用户想取消其中某个宏定义，用-Umacro选项，这相当于把#undef macro放在要编译的源文件的开头。 -Idir 将dir目录加到搜寻头文件的目录列表中去，并优先于在gcc缺省的搜索目录。在有多个-I选项的情况下，按命令行上-I选项的前后顺序搜索。dir可使用相对路径，如-I../inc等。 -O 对程序编译进行优化，编译程序试图减少被编译程序的长度和执行时间，但其编译速度比不做优化慢，而且要求较多的内存。 -O2 允许比-O更好的优化，编译速度较慢，但结果程序的执行速度较快。 -g 产生一张用于调试和排错的扩展符号表。-g选项使程序可以用GNU的调试程序GDB进行调试。优化和调试通常不兼容，同时使用-g和-O（-O2）选项经常会使程序产生奇怪的运行结果。所以不要同时使用-g和-O（-O2）选项。 -fpic或-fPIC 产生位置无关的目标代码，可用于构造共享函数库。 以上是gcc的编译选项。gcc的命令行上还可以使用连接选项。事实上，gcc将所有不能识别的选项传递给连接程序ld。连接程序ld将几个目标文件和库 程序组合成一个可执行文件，它要解决对外部变量、外部过程、库程序等的引用。但我们永远不必要显式地调用ld。利用gcc命令去连接各个文件是很简单的， 即使在命令行里没有列出库程序，gcc也能保证某些库程序以正确的次序出现。 gcc的常用连接选项有下列几个： -Ldir 将dir目录加到搜寻-l选项指定的函数库文件的目录列表中去，并优先于gcc缺省的搜索目录。在有多个-L选项的情况下，按命令行上-L选项的前后顺序搜索。dir可使用相对路径。如-L../lib等。 -lname 在连接时使用函数库libname.a，连接程序在-Ldir选项指定的目录下和/lib，/usr/lib目录下寻找该库文件。在没有使用-static选项时，如果发现共享函数库libname.so，则使用libname.so进行动态连接。 -static 禁止与共享函数库连接。</li>
</ol>
<p>近日来下载的源代码欲编译，可是总是提示“权限不够”，检查了相应文件的权限，都没有问题。无奈之下， 把/bin/sh，/bin/bash等程序的权限都折腾了几遍，却总是不行，返回下面的出错信息： XXXX$ ./configure bash: ./configure: /bin/sh: bad interpreter: 权限不够 情急之下，用“权限不够”作为关键词，在Google中很搜了一把，都是有几个同志碰到了同样的问题，只是论坛中的答复，却没一个让人满意的，提问的人都 说明了文件本身的权限没有问题，可得到的答复却总是“喔，试试chmod 755”或者”sh ./configure“（用直接输入sh的方法，脚本本身执行结果最后仍旧会出错，如找不到CC编译器）之类的答案，没一个好使。为了找答案，我看了N 多的搜索结果，眼睛都看花了，终于忍受不住，放弃了N天。 今日，实在是需要编译程序，没办法又搜了大半天，和上次一样的结果。没办法之后自己反复尝试了几次，明明直接敲“sh“就可以执行，咋就是最后还是出错 呢，而且难道我每次都非得敲“sh“，更是郁闷！ 突然灵感一现，敲”ch“可以，应该问题的本身不在”sh“上，估计是”bad interpreter“在作祟，果然，拿”bad interpreter“再到Google中搜索一把，终于被我找到了。外国人的论坛，某人提了同样的问题，答复的答案也没一个正确，最后是提问人自己搞定给出了答案：） 弄了半天，居然是因为脚本所在硬盘的文件格式搞的鬼。是在光驱下直接执行的，copy到/home 下即（ext3硬盘格式）下，啊，总算皇天不负有心人，终于搞定了！ 可以安心睡觉了：）</p>
            </div><!-- /.entry-content -->


        </div><!-- /.eleven.columns -->

<div class="three columns">
<h4>站内搜索</h4>
              <div class="navbar-search pull-right">
                <script type="text/javascript">(function(){document.write(unescape('%3Cdiv id="bdcs"%3E%3C/div%3E'));var bdcs = document.createElement('script');bdcs.type = 'text/javascript';bdcs.async = true;bdcs.src = 'http://znsv.baidu.com/customer_search/api/js?sid=8305292233022102519' + '&plate_url=' + encodeURIComponent(window.location.href) + '&t=' + Math.ceil(new Date()/3600000);var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(bdcs, s);})();</script>
              </div>    

<h4>页面</h4>

 <ul>
  </ul>

<h4>分类</h4>
<ul class="blank">
		<li><a href="/blog/category/android.html">android</a></li>
		<li><a href="/blog/category/api.html">api</a></li>
		<li><a href="/blog/category/git.html">git</a></li>
		<li><a href="/blog/category/go.html">go</a></li>
		<li><a href="/blog/category/hack.html">hack</a></li>
		<li><a href="/blog/category/ios.html">ios</a></li>
		<li><a href="/blog/category/java.html">java</a></li>
		<li><a href="/blog/category/javascript.html">javascript</a></li>
		<li><a href="/blog/category/linux.html">linux</a></li>
		<li><a href="/blog/category/mysql.html">mysql</a></li>
		<li><a href="/blog/category/operation.html">operation</a></li>
		<li><a href="/blog/category/others.html">others</a></li>
		<li><a href="/blog/category/php.html">php</a></li>
		<li><a href="/blog/category/program.html">program</a></li>
		<li><a href="/blog/category/python.html">python</a></li>
		<li><a href="/blog/category/read.html">read</a></li>
		<li><a href="/blog/category/soft.html">soft</a></li>
		<li><a href="/blog/category/success.html">success</a></li>
		<li><a href="/blog/category/test.html">test</a></li>
		<li><a href="/blog/category/vcs.html">vcs</a></li>
		<li><a href="/blog/category/windows.html">windows</a></li>
</ul>


<h4>标签</h4>


<nav class="widget">
  <h4>友情链接</h4>
  <ul class="blank">
    <li><a href="/">搜索</a></li>
    <li><a href="/123">导航</a></li>
    <li><a href="/doc">文档</a></li>
    <li><a href="/blog">博客</a></li>
  </ul>
</nav>

</div> </div><!-- /.row -->


</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">

    
        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">





              </ul>
            </div>
          </div>
        </footer>

    </div>


  <script src="/blog/theme/js/libs/jquery-1.9.1.min.js"></script>
  <script src="/blog/theme/js/libs/gumby.min.js"></script>
  <script src="/blog/theme/js/plugins.js"></script>
</body>
</html>