<!DOCTYPE html>
<html lang="zh_cn">
<head>

        <title>闲谈“如何优化SSH框架的项目”</title>
        <meta charset="utf-8" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="/blog/theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="/blog/theme/style.css" />
        <link rel="stylesheet" type="text/css" href="/blog/theme/pygment.css" />

        <script src="/blog/theme/js/libs/modernizr-2.6.2.min.js"></script>




</head>

<body id="index" class="home">


    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="/blog/">逍遥の博客 <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>
             
              <ul class="columns">
                <li><a href="/blog/">首页</a></li>


              </ul>

            </div>

<section id="content" class="body">

   <div class="row">
        <div class="eleven columns">


            <header>
              <h2 class="entry-title">
                <a href="/blog/3975.html" rel="bookmark"
                   title="Permalink to 闲谈“如何优化SSH框架的项目”">闲谈“如何优化SSH框架的项目”</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="1970-01-01T00:00:00+08:00">
                Thu 01 January 1970
              </abbr>
              <address class="vcard author">By 
                <a class="url fn" href="/blog/author/u0mo5.html"> u0mo5</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <p>使用struts框架的好处之一就是所有action类继承一个基类,将访问控制在基类中处理.2.所有的action类都继承自baseaction,一个资源对应一个action类.1.实现一个继承自struts的action的baseaction.从action类名提取资源名称,在mapping中的parameter提取当前action做为opertion.将userid,resource,operation作为参数传递到权限验证接口进行验证.参考struts的dispatchaction使用反射机制调用请求的方法. 在处理一个业务事务中,需要的不止一个action方法,例如修改资源这个业务过程,它需要两个ation,一个是显示资源信息进行编辑的方法edit,一个是将编辑好后的资源信息提交到服务器进行持久化操作的方法update.这样就是业务方法与action方法不对应.这里我们不需要对edit这个方法进行访问控制,需要控制的是update方法.并且在进行权限指派中也不需要edit这个权限.个人认为，Struts在Model层的东西太少了或是说几乎没有涉及。Spring的核心是Ioc模式(又称DI：Dependency Injection)实现的Bean工厂(BeanFactory)和AOP(Aspect Oriented Programming)，我们可以用Struts+Spring，将两者结合可以将其自身的特点互补。完成我们要做的工作。一、Hibernate是JDBC的轻量级的对象封装，它是一个独立的对象持久层框架，和App Server，和EJB没有什么必然的联系。Hibernate可以用在任何JDBC可以使用的场合，例如Java应用程序的数据库访问代码，DAO接口的实现类，甚至可以是BMP里面的访问数据库的代码。从这个意义上来说，Hibernate和EB不是一个范畴的东西，也不存在非此即彼的关系。  二、Hibernate是一个和JDBC密切关联的框架，所以Hibernate的兼容性和JDBC驱动，和数据库都有一定的关系，但是和使用它的Java程序，和App Server没有任何关系，也不存在兼容性问题。  三、Hibernate不能用来直接和Entity Bean做对比，只有放在整个J2EE项目的框架中才能比较。并且即使是放在软件整体框架中来看，Hibernate也是做为JDBC的替代者出现的，而不是Entity Bean的替代者出现的，让我再列一次我已经列n次的框架结构： 传统的架构： 1) Session Bean &lt;-&gt; Entity Bean &lt;-&gt; DB 为了解决性能障碍的替代架构： 2) Session Bean &lt;-&gt; DAO &lt;-&gt; JDBC &lt;-&gt; DB 使用Hibernate来提高上面架构的开发效率的架构：   3) Session Bean &lt;-&gt; DAO &lt;-&gt; Hibernate &lt;-&gt; DB 就上面3个架构来分析：  1、内存消耗：采用JDBC的架构2无疑是最省内存的，Hibernate的架构3次之，EB的架构1最差。     2、运行效率：如果JDBC的代码写的非常优化，那么JDBC架构运行效率最高，但是实际项目中，这一点几乎做不到，这需要程序员非常精通JDBC，运用Batch语句，调整PreapredStatement的Batch Size和Fetch Size等参数，以及在必要的情况下采用结果集cache等等。而一般情况下程序员是做不到这一点的。因此Hibernate架构表现出最快的运行效率。EB的架构效率会差的很远。     3、开发效率：在有JBuilder的支持下以及简单的项目，EB架构开发效率最高，JDBC次之，Hibernate最差。但是在大的项目，特别是持久层关系映射很复杂的情况下，Hibernate效率高的惊人，JDBC次之，而EB架构很可能会失败。    4、分布式，安全检查，集群，负载均衡的支持 由于有SB做为Facade，3个架构没有区别。 四、EB和Hibernate学习难度在哪里？ EB的难度在哪里？不在复杂的XML配置文件上，而在于EB运用稍微不慎，就有严重的性能障碍。所以难在你需要学习很多EJB设计模式来避开性能问题，需要学习App Server和EB的配置来优化EB的运行效率。做EB的开发工作，程序员的大部分精力都被放到了EB的性能问题上了，反而没有更多的精力关注本身就主要投入精力去考虑的对象持久层的设计上来。 Hibernate难在哪里？不在Hibernate本身的复杂，实际上Hibernate非常的简单，难在Hibernate太灵活了。 当你用EB来实现持久层的时候，你会发现EB实在是太笨拙了，笨拙到你根本没有什么可以选择的余地，所以你根本就不用花费精力去设计方案，去平衡方案的好坏，去费脑筋考虑选择哪个方案，因为只有唯一的方案摆在你面前，你只能这么做，没得选择。 Hibernate相反，它太灵活了，相同的问题，你至少可以设计出十几种方案来解决，所以特别的犯难，究竟用这个，还是用那个呢？这些方案之间到底有什么区别呢？他们的运行原理有什么不同？运行效率哪个比较好？光是主键生成，就有七八种方案供你选择，你为难不为难？集合属性可以用Set，可以用List，还可以用Bag，到底哪个效率高，你为难不为难？查询可以用iterator，可以用list，哪个好，有什么区别？你为难不为难？复合主键你可以直接在hbm里面配置，也可以自定义CustomerType，哪种比较好些？你为难不为难？对于一个表，你可以选择单一映射一个对象，也可以映射成父子对象，还可以映射成两个1:1的对象，在什么情况下用哪种方案比较好，你为难不为难？ 这个列表可以一直开列下去，直到你不想再看下去为止。当你面前摆着无数的眼花缭乱的方案的时候，你会觉得幸福呢？还是悲哀呢？如果你是一个负责的程序员，那么你一定会仔细研究每种方案的区别，每种方案的效率，每种方案的适用场合，你会觉得你已经陷入进去拔不出来了。如果是用EB，你第一秒种就已经做出了决定，根本没得选择，比如说集合属性，你只能用Collection，如果是Hibernate，你会在Bag，List和Set之间来回犹豫不决，甚至搞不清楚的话，程序都没有办法写。</p>
            </div><!-- /.entry-content -->


        </div><!-- /.eleven.columns -->

<div class="three columns">
<h4>站内搜索</h4>
              <div class="navbar-search pull-right">
                <script type="text/javascript">(function(){document.write(unescape('%3Cdiv id="bdcs"%3E%3C/div%3E'));var bdcs = document.createElement('script');bdcs.type = 'text/javascript';bdcs.async = true;bdcs.src = 'http://znsv.baidu.com/customer_search/api/js?sid=8305292233022102519' + '&plate_url=' + encodeURIComponent(window.location.href) + '&t=' + Math.ceil(new Date()/3600000);var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(bdcs, s);})();</script>
              </div>    

<h4>页面</h4>

 <ul>
  </ul>

<h4>分类</h4>
<ul class="blank">
		<li><a href="/blog/category/android.html">android</a></li>
		<li><a href="/blog/category/api.html">api</a></li>
		<li><a href="/blog/category/essay.html">essay</a></li>
		<li><a href="/blog/category/git.html">git</a></li>
		<li><a href="/blog/category/go.html">go</a></li>
		<li><a href="/blog/category/hack.html">hack</a></li>
		<li><a href="/blog/category/ios.html">ios</a></li>
		<li><a href="/blog/category/java.html">java</a></li>
		<li><a href="/blog/category/javascript.html">javascript</a></li>
		<li><a href="/blog/category/linux.html">linux</a></li>
		<li><a href="/blog/category/mysql.html">mysql</a></li>
		<li><a href="/blog/category/operation.html">operation</a></li>
		<li><a href="/blog/category/others.html">others</a></li>
		<li><a href="/blog/category/php.html">php</a></li>
		<li><a href="/blog/category/program.html">program</a></li>
		<li><a href="/blog/category/python.html">python</a></li>
		<li><a href="/blog/category/read.html">read</a></li>
		<li><a href="/blog/category/soft.html">soft</a></li>
		<li><a href="/blog/category/success.html">success</a></li>
		<li><a href="/blog/category/test.html">test</a></li>
		<li><a href="/blog/category/vcs.html">vcs</a></li>
		<li><a href="/blog/category/windows.html">windows</a></li>
</ul>


<h4>标签</h4>


<nav class="widget">
  <h4>友情链接</h4>
  <ul class="blank">
    <li><a href="/">搜索</a></li>
    <li><a href="/123">导航</a></li>
    <li><a href="/doc">文档</a></li>
    <li><a href="/blog">博客</a></li>
  </ul>
</nav>

</div> </div><!-- /.row -->


</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">

    
        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">





              </ul>
            </div>
          </div>
        </footer>

    </div>


  <script src="/blog/theme/js/libs/jquery-1.9.1.min.js"></script>
  <script src="/blog/theme/js/libs/gumby.min.js"></script>
  <script src="/blog/theme/js/plugins.js"></script>
</body>
</html>