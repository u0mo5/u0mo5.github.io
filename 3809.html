<!DOCTYPE html>
<html lang="english">
<head>

        <title>JAVA中的糕富帅技术——反射（一）</title>
        <meta charset="utf-8" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="/theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="/theme/style.css" />
        <link rel="stylesheet" type="text/css" href="/theme/pygment.css" />

        <script src="/theme/js/libs/modernizr-2.6.2.min.js"></script>




</head>

<body id="index" class="home">


    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="/">读书圈博客 <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>
             
              <ul class="columns">
                <li><a href="/">Home</a></li>


              </ul>
            </div>

<section id="content" class="body">

   <div class="row">
        <div class="eleven columns">


            <header>
              <h2 class="entry-title">
                <a href="/3809.html" rel="bookmark"
                   title="Permalink to JAVA中的糕富帅技术——反射（一）">JAVA中的糕富帅技术——反射（一）</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="1970-01-01T00:00:00+08:00">
                Thu 01 January 1970
              </abbr>
              <address class="vcard author">By 
                <a class="url fn" href="/author/u0mo5.html"> u0mo5</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <p>前言
　　突然发现好久没写博客了，前面写的都是关于Android的东西，今天心血来潮突然有一种冲动想写一篇基于JAVA技术的博客，别问我为什么？有钱、任性！
　　今天就来谈谈反射机制；学过JAVA的人不一定懂得反射，但是一定听说过反射，不过也仅仅是听说过而已；因为反射用的地方也不会那么多，但是反射用的妙经常会解决我们挠破头皮的大问题。至于诸如为什么叫做反射、而不叫做正射倒射此类的历史问题，还是交给历史学家去研究吧。。。
反射的基石
　　在谈反射之前，我们应该先了解下类的概念来引入。类是一种抽象的概念，举个例子“我爸是李刚我爸李双江”，从这句话中我们发现有李刚、李双江这两个人，我们来抽象它们的特点，我们发现它们都像人。没错，那么我们就可以将人作为它们的一个抽象，反过来说李刚和李双江就是人的一个具体实例；所以我们可以用一个Person类代表人来表示这种抽象。既然理解了类的概念，那些年那些陪我们度过日日夜夜的java类们，我们是不是也应该抽象出一个类来证明一下他们，没错，那就是Class了！
　　Class就是java类的抽象，它抽象出了java的共性，如类的名字、类的构造方法、类的成员变量、类的老爸、类的方法等等等。既然这么说，那么我们通过这个Class，我们就可以得到这个类的方方面面的信息、兴许还能比查户口还详细呢。我们创建出的每一个类，例如person类，说到底也就是我们实例化了一个Class的实例，来保存person类的名字、变量、方法这些信息，在内存中表示就是保存了person类的字节码，如果你理解了这些并且接受了我的看法，那么咱们有共同语言，可以继续往下说。
　　既然person类有拥有自己的字节码，那么我们可以获取到这个字节码吗？答案是肯定的，而且还不止一种方法。参见代码：</p>
<p>public static void main(String[] args) throws Exception {
　　//第一种方法，直接通过Person类来获取字节码
　　Class cls1 = Person.class;
　　//第二种方法，通过类的实例来获取Person类的字节码
　　Person person = new Person();
　　Class cls2 = person.getClass();
　　//第三种方法，调用Class类的静态方法来获取对应类的字节码，该方法会抛出异常
　　Class cls3 = Class.forName("Person");
}</p>
<p>从代码中看，我们可以断定：Person类的字节码就是Class的具体实例；我们也可以猜到，至于类的字节码有包含什么东东，大家尽管猜吧，后面我会慢慢讲解。我们再来看看下面的代码：</p>
<p>System.out.println(cls1 == cls2);
　　System.out.println(cls2 == cls3);</p>
<p>我们运行程序，会发现输出了：
truetrue
这三个玩意竟然是同一个东西，那么就很好解释了：在java的虚拟机中，每一个类都会被保存成为一个字节码，用来保存该类的信息如名字、父类、变量、方法等。一个类的字节码在虚拟机中有且只有一个，也就是在第一次加载该类的时候会将类的字节码加载到java虚拟机中，而上面有三种方法可以从虚拟机中获取类的字节码（PS:第三种方法最为常用），但是你别疑惑获取这个字节码干嘛嘛用，我们要反射嘛，说白了我们就是要来强暴这字节码（Class）。。。。。(～ o ～)~zZ
 理解反射
　　既然前面讲解了Class类，现在我们可以开始讲反射了。反射是什么呢？反射就是将类的各种成分映射成各种类，我们知道一个java类可以用一个class的对象来表示，这个类的组成成分有名字、变量、构造方法等信息，我们当然可以用一个个java类的表示。换句话说，表示java类的Class类提供了一系列的方法给我们用来获取其中的变量、方法、构造方法等信息，这些信息也有相应的类的实例来表示，也就是Field、Method、Constructor等等。或者更通俗的说，Field就是java类中的所有变量的抽象、同理Method就是java类中所有方法的抽象，如果还是看不懂，很正常，往下看代码估计更好理解。
构造方法的反射
　　从前面我们知道，Constructor就是java类所有构造方法的抽象。那么我们怎么通过反射来获取类的构造方法呢，参见代码：</p>
<p>public class Test{</p>
<div class="highlight"><pre><span></span>public static void main(String[] args) throws Exception {

    Class cls = Person.class;//获取Person类的字节码

    Constructor constructor1 = cls.getConstructor();//调用getConstructor()获取Person无参构造方法
    Person p1 = (Person) constructor1.newInstance();//通过调用newInstance()来执行无参构造方法

    Constructor constructor2 = cls.getConstructor(int.class);//调用getConstructor(*.class)获取Person带参构造方法
    Person p2 = (Person) constructor2.newInstance(1);//通过调用newInstance(int)来执行带参构造方法
}
</pre></div>


<p>}</p>
<p>class Person{  <br>
    public Person(){System.out.println("无参构造方法");}
    public Person(int i){System.out.println("带参构造方法");}
}</p>
<p>控制台输出：
无参构造方法带参构造方法
　　这里我们开始讲解一下，代码通过Person.class来获取Person类的字节码并将其保存在一个Class类的实例cls中，然后再通过cls.getConstructor()来获取字节码中的构造方法并将其放入Constructor的实例constructor之中，很明显，这个constructor并不是Person的构造方法，而是保存Person构造方法的一个实例，所以我们可以通过调用newInstance()来获取保存在constructor中的person类的构造方法并执行，构造方法执行并返回一个Object的实例，并将其强转为Person并保存在person的变量中，这就是调用反射来获取构造方法生成实例的全过程。
　　在代码中，我们也可以知道怎么获取带参的构造方法，这是我们需要在getConstructor()是传入构造方法对应参数的字节码，例如代码中Person(int i)我们需要传入一个int.class（或者是Integet.TYPE）的字节码提供给Class定位需要获取的构造方法。但是如果你比较贪心想获取全部的构造方法，没问题，通过getConstructors()：</p>
<p>Class cls = Person.class;//获取Person类的字节码
Constructor[] constructors = cls.getConstructors();//调用getConstructor()获取Person无参构造方法
for(Constructor c : constructors){
　　//Person p = c.newInstance(****);遍历执行构造方法
}</p>
<p>然后通过for循环，就可以处理你所需要的构造方法了。
成员变量的反射
　　我们说完了构造方法的反射，我们就接下来谈谈成员变量的反射的用法。惯例还是先看代码：</p>
<p>public class Test{</p>
<div class="highlight"><pre><span></span>public static void main(String[] args) throws Exception {

    Person p = new Person(&quot;小红&quot;, 20);

    Class cls = Class.forName(&quot;com.net168.test.Person&quot;);
    Field fieldName = cls.getField(&quot;name&quot;);
    //fieldNmae的值是小红吗？错！它只是代表Person类身上name的这个变量，并没有对应到对象身上
</pre></div>


<p>//        System.out.println(fieldNmae); 
        //fieldNmae不代表具体的值，只代表一个变量，所以我们需要传入一个person实例才能获取到其对应的值
        System.out.println(fieldName.get(p));
    }</p>
<p>}</p>
<p>class Person{  <br>
    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    public String name;
    private int age;//对于某些人来说，年龄是秘密！
}</p>
<p>跟构造方法的反射的实现差不多，我们也是先通过获取Person的字节码cls，然后从其中将Person的成员变量映射成一个Field类，在这里我们将Person.name这个变量映射成fieldName这个对象，当然我们不可能单纯的从fieldName这个对象中获取咱们的“小红”，因为fieldName是从cls中获取的而并不是从person的实例中获取的，所以它值并不是小红；而是我们可以通过小红这个person的实例p与fieldName联系起来，也就是调用fieldName.get(p)才能获取小红这个字符串。
　　但是我们如果想获取小红年龄呢，女人的年龄大多是秘密，私有变量我们也可以这样获取吗？修改下代码：</p>
<p>Person p = new Person("小红", 20);
Class cls = Class.forName("com.net168.test.Person");
Field fieldAge = cls.getField("age");
System.out.println(fieldAge.get(p));</p>
<p>执行结果是：
Exception in thread "main" java.lang.NoSuchFieldException: ageat java.lang.Class.getField(Unknown Source)at com.net168.test.Test.main(Test.java:11)
没有这个字段，明明是有这个age的字段呀！但是我们发现，原来这个女生的年龄是私有的，她就是不肯告诉咱们啊，那怎么办？她不想告诉我们，我们就没法知道了吗？屌丝是不会那么容易屈服的！所以我们可以稍作一点处理，如下：</p>
<p>Person p = new Person("小红", 20);
Class cls = Class.forName("com.net168.test.Person");
Field fieldAge = cls.getDeclaredField("age");//获取类的私有变量
fieldAge.setAccessible(true);//设置该私有变量可被外面访问
System.out.println(fieldAge.get(p));</p>
<p>可以通过getDeclaredField()来获取Person类的私有变量，而且我们还可以在获取到外界看不到的私有变量后，再通过setAccessible(true)设置该私有变量可以被强制访问。暴力吧，JAVA的反射也被有些人叫做暴力反射。。。运行代码，我们就知道了小红的芳龄 了：20
成员方法的反射
　　如果大家看懂了前面成员变量和构造方法的反射，基本上再了解成员方法的反射就没有什么困难了，不卖关子，还是先上下代码：</p>
<p>public class Test{</p>
<div class="highlight"><pre><span></span>public static void main(String[] args) throws Exception {
    Person p = new Person();
    Class cls = p.getClass();//获取Person的字节码
    //获取setName()方法，需要传入参数为String
    Method method1 = cls.getMethod(&quot;setName&quot;, String.class);
    method1.invoke(p, &quot;小明&quot;);//关联p,输入“小明”并执行该方法
    //获取getName()方法，无参则设为null
    Method method2 = cls.getMethod(&quot;getName&quot;, null);
    String name = (String) method2.invoke(p, null);//invoke返回的类型为Object
    System.out.println(name);
    //获取静态方法，由于静态方法只依赖与类，所以不需要提供具体的实例
    Method method3 = cls.getMethod(&quot;show&quot;, int.class);
</pre></div>


<p>//        method3.invoke(p, 1);提供具体实例p也可通过编译
        method3.invoke(null, 1);</p>
<div class="highlight"><pre><span></span>}
</pre></div>


<p>}</p>
<p>class Person{  <br>
    public String name;
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name = name;
        System.out.println("设置name值为：" + name);
    }
    public static void show(int i){
        System.out.println("这是一个静态方法:" + i);
    }
}</p>
<p>程序运行结果：
设置name值为：小明小明这是一个静态方法:1
　　在方法的反射中，我们是利用了Method这个类，由于跟构造方法类似，所以我不就再就获取有参无参的方法的不同之处进行讲解。总体来说，就是通过Person的字节码获取到Person类中对应的方法并将其保存到Method的一个对象中，然后通过这个对象跟Person的具体实例进行搭配，通过invoke()就可以调用到具体实例的对应方法。在这里我们需要注意的时静态方法的反射，由于静态方法属于一个类并不是属于特定的一个对象，所以我们在调用静态方法的invoke()时，并不需要传入一个对象，当然你非要传入一个具体的实例也是没有关系的，答案依然正确。
 
对于反射就先讲这么多吧，后面有时间再来讲讲反射的深入应用以及反射在框架搭建的用处。又浪费我一晚上游戏时间了。。。。任性呀。。。
 
 
作者：enjoy风铃出处：http://www.cnblogs.com/net168/本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则下次不给你转载了</p>
            </div><!-- /.entry-content -->


        </div><!-- /.eleven.columns -->

<div class="three columns">

<h4>Pages</h4>

 <ul>
  </ul>

<h4>Categories</h4>
<ul class="blank">
		<li><a href="/category/default.html">default</a></li>
		<li><a href="/category/java.html">java</a></li>
		<li><a href="/category/javascript.html">javascript</a></li>
		<li><a href="/category/linux.html">linux</a></li>
		<li><a href="/category/mysql.html">mysql</a></li>
		<li><a href="/category/php.html">php</a></li>
		<li><a href="/category/python.html">python</a></li>
		<li><a href="/category/windows.html">windows</a></li>
</ul>


<h4>Tags</h4>


<nav class="widget">
  <h4>Social</h4>
  <ul class="blank">
    <li><a href="http://bookfuns.com">读书圈</a></li>
    <li><a href="http://123.bookfuns.com">网址大全</a></li>
  </ul>
</nav>

</div> </div><!-- /.row -->


</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">

    
        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">





              </ul>
            </div>
          </div>
        </footer>

    </div>


  <script src="/theme/js/libs/jquery-1.9.1.min.js"></script>
  <script src="/theme/js/libs/gumby.min.js"></script>
  <script src="/theme/js/plugins.js"></script>
</body>
</html>