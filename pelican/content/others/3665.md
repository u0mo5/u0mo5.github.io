Title: 由一个简单算法想到的程序员素养问题
Date: 1970-01-01 00:00:00
Modified: 1970-01-01 00:00:00
cat: default
Tags: 
Slug: 3665
Authors: u0mo5 
Summary: 

题记：五月从帝都回到武汉，旅游半个月后开始找新工作，六月选择了一家华中地区为数不多的移动互联网公司入职至今，略有感触——比较帝都码农与武汉码农的平均水平，就跟两个城市的经济发展水平差异一样大，不是说武汉这边没有优秀的程序员（我也算半个嘛），而是说平均水平确实不如其他一线城市。想想也正常，巨头公司都扎堆北上广深，以极具竞争力的薪酬福利和巨头光环吸引着广大程序员，反观武汉的互联网发展尚处在初级阶段，无论从公司规模、名气还是最实际的薪酬福利方面均不如一线城市，自然无法吸引广大程序员咯。本人在新公司待了近三个月，慢慢发现代码中的一些问题，而这些问题中除开因为个人能力短时间无法解决的，剩下的就是我想探讨的程序员素养问题。
 
　　先说下我所认为的程序员素养吧，我认为应包括以下几个方面呢：1，扎实的功底——扎实掌握操作系统，数据结构等大学基本课程，鼓吹基础无用论的，必定是个三流程序员。2，学习心态——对你所调用的，一定要有好奇心，尽可能花时间去了解API背后的东西，去了解系统框架是如何运作；对新的领域，一定要有好奇心，多尝试多学习，他山之石，可以攻玉。3，善于自学、总结、发问——工作后没有人去手把手教你，只要自己刻苦专研，并总结成博客或者笔记之类的成果，才又提高；在遇到自己能力范围内解决不了的问题，要善于向牛人请求点播，而一针见血的问题往往也会收获一针见血的回答。
 
　　举一个简单的例子来讨论素养1，需求如下：已经完成排序的1万条数据，现在需要取前5000条作为最终数据，考虑到数据量较大，如果是新建列表，遍历旧列表的5000条并重新建立引用，有(引用类型所占字节 * 5000)字节的空间上的浪费，而且这种方式显得比较笨拙。
 
　　所以，略加思索后写出了以下代码：
 
复制代码
List&lt;Item&gt; rankItems = new ArrayList&lt;Item&gt;();
// 生成数据+排序
...
while (rankItems.size() &gt; 5000) {
    rankItems.remove(rankItems.size() - 1);
}
复制代码
　　简单分析，对于ArrayList大家都不陌生，是以数组方式实现的链表，remove(index)方法实质上调用的是System.arraycopy()方法，源码如下：
 
复制代码
    /**
     * Removes the object at the specified location from this list.
     *
     * @param index
     *            the index of the object to remove.
     * @return the removed object.
     * @throws IndexOutOfBoundsException
     *             when {@code location &lt; 0 || &gt;= size()}
     */
    @Override public E remove(int index) {
        Object[] a = array;
        int s = size;
        if (index &gt;= s) {
            throwIndexOutOfBoundsException(index, s);
        }
        @SuppressWarnings("unchecked") E result = (E) a[index];
        System.arraycopy(a, index + 1, a, index, --s - index);
        a[s] = null;  // Prevent memory leak
        size = s;
        modCount++;
        return result;
    }
复制代码
　　System.arraycopy()是native方法，调用的应该是C语言中的memcpy()，虽然copy的source地址和dest地址都是相同的，无需分配新内存，但是要经过5000次的内存IO读写才能删除ArrayList中的数据。究其原因是因为ArrayList的数组实现方式，不利于在指定位置做添加/删除操作，所以思考后有了以下代码：
 
复制代码
List&lt;Item&gt; rankItems = new LinkedList&lt;Item&gt;();
// 生成数据+排序
...
while (rankItems.size() &gt; 5000) {
    rankItems.remove(rankItems.size() - 1);
}
复制代码
　　再分析LinkedList的删除效率，是否比ArrayList高了呢？LinkedList的remove(index)方法实现如下：
 
复制代码
/**
     * Removes the object at the specified location from this {@code LinkedList}.
     *
     * @param location
     *            the index of the object to remove
     * @return the removed object
     * @throws IndexOutOfBoundsException
     *             if {@code location &lt; 0 || &gt;= size()}
     */
    @Override
    public E remove(int location) {
        if (0 &lt;= location &amp;&amp; location &lt; size) {
            Link&lt;E&gt; link = voidLink;
            if (location &lt; (size / 2)) {
                for (int i = 0; i &lt;= location; i++) {
                    link = link.next;
                }
            } else {
                for (int i = size; i &gt; location; i--) {
                    link = link.previous;
                }
            }
            Link&lt;E&gt; previous = link.previous;
            Link&lt;E&gt; next = link.next;
            previous.next = next;
            next.previous = previous;
            size--;
            modCount++;
            return link.data;
        }
        throw new IndexOutOfBoundsException();
    }
复制代码
　　LinkedList的删除操作很简单，只需要修改指定index对象其前后对象的引用即可，但是在指针移动到指定index之前，需要移动1/2个列表长度，效率并非最高，能否将移动的操作也简化掉呢？既然是已排好序的列表，每次删除都删除列表末尾的对象，那我们可以使用LinkedList提供的removeLast()方法，代码如下：
 
复制代码
List&lt;Item&gt; rankItems = new LinkedList&lt;Item&gt;();
// 生成数据+排序
...
while (rankItems.size() &gt; 5000) {
    rankItems.removeLast();
}
复制代码
　　分析removeLast()的效率，LinkedList的removeLast()方法实现如下：
 
复制代码
/**
     * Removes the last object from this {@code LinkedList}.
     *
     * @return the removed object.
     * @throws NoSuchElementException
     *             if this {@code LinkedList} is empty.
     */
    public E removeLast() {
        Link&lt;E&gt; last = voidLink.previous;
        if (last != voidLink) {
            Link&lt;E&gt; previous = last.previous;
            voidLink.previous = previous;
            previous.next = voidLink;
            size--;
            modCount++;
            return last.data;
        }
        throw new NoSuchElementException();
    }
复制代码
　　LinkedList的removeLast()方法没有移动指针的操作，只需要借助于列表尾的voidLink，即可完成对列表尾部对象的删除，效率上较高。
