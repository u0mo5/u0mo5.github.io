Title: oracle,mysql,SqlServer三种数据库的分页查询
Date: 1970-01-01 00:00:00
Modified: 1970-01-01 00:00:00
cat: mysql
Tags: 
Slug: 3796
Authors: u0mo5 
Summary: 

MySql：
MySQL数据库实现分页比较简单，提供了 LIMIT函数。一般只需要直接写到sql语句后面就行了。LIMIT子 
句可以用来限制由SELECT语句返回过来的数据数量，它有一个或两个参数，如果给出两个参数， 
第一个参数指定返回的第一行在所有数据中的位置，从0开始（注意不是1），第二个参数指定最多返回行数。例如：select * from table 
WHERE … LIMIT 10; #返回前10行select * from table WHERE … LIMIT 0,10; 
#返回前10行select * from table WHERE … LIMIT 10,20; #返回第10-20行数据
 
Oracle：
考虑mySql中的实现分页，select * from 表名  limit 开始记录数,显示多少条;就可以实现我们的分页效果。
但是在oracle中没有limit关键字，但是有 rownum字段
rownum是一个伪列，是oracle系统自动为查询返回结果的每行分配的编号，第一行为1，第二行为2，以此类推。。。。
第一种：
 

复制代码 
代码如下:

SELECT * FROM (                   
SELECT A.*, ROWNUM RN                    FROM (SELECT * FROM TABLE_NAME) A 
                   WHERE ROWNUM &lt;= 40)WHERE RN &gt;= 21
 
 


 
其中最内层的查询SELECT * FROM TABLE_NAME表示不进行翻页的原始查询语句。ROWNUM &lt;= 40和RN &gt;= 
21控制分页查询的每页的范围。
上面给出的这个分页查询语句，在大多数情况拥有较高的效率。分页的目的就是控制输出结果集大小，将结果尽快的返回。在上面的分页查询语句中，这种考虑主要体现在WHERE 
ROWNUM &lt;= 40这句上。
选择第21到40条记录存在两种方法，一种是上面例子中展示的在查询的第二层通过ROWNUM &lt;= 
40来控制最大值，在查询的最外层控制最小值。而另一种方式是去掉查询第二层的WHERE ROWNUM &lt;= 
40语句，在查询的最外层控制分页的最小值和最大值。
第二种：
 

复制代码 
代码如下:

select * 
from (select e.*,rownum  r from  
(select * from emp order by sal desc) e ) e1 where e1.r&gt;21 and e1.r&lt;=40;
 
 


 
红色部分：按照工资降序排序并查询所有的信息。 
棕色部分：得到红色部门查询的值，并查询出系统的rownum并指定上别名。这一句就比较关键，起了一个过渡的作用，首先要算出rownum来对红色部分指定上序号，也可以为蓝色外面部分用到这个变量。指定上查询的开始记录数和结束记录的条件。
蓝色部分：指定记录从第几条开始到第几条结束，取出棕色部门的值来作为查询条件的变量
总结：绝大多数的情况下，第一个查询的效率比第二个高得多。 
SqlServer：
分页方案一：(利用Not In和SELECT TOP分页)
语句形式：
 

复制代码 
代码如下:

SELECT TOP 10 *
 
FROM TestTable
WHERE (ID NOT IN
(SELECT TOP 20 id
FROM TestTable
ORDER BY id))
ORDER BY ID
 
SELECT TOP 页大小 *
FROM TestTable
WHERE (ID NOT IN
(SELECT TOP 页大小*页数 id
FROM 表
ORDER BY id))
ORDER BY ID
 


 
分页方案二：(利用ID大于多少和SELECT TOP分页）
语句形式：
 

复制代码 
代码如下:

SELECT TOP 10 *
 
FROM TestTable
WHERE (ID &gt;
(SELECT MAX(id)
FROM (SELECT TOP 20 id
FROM TestTable
ORDER BY id) AS T))
ORDER BY ID
 
SELECT TOP 页大小 *
FROM TestTable
WHERE (ID &gt;
(SELECT MAX(id)
FROM (SELECT TOP 页大小*页数 id
FROM 表
ORDER BY id) AS T))
ORDER BY ID
 


 
分页方案三：(利用SQL的游标存储过程分页)
 

复制代码 
代码如下:

create procedure XiaoZhengGe
 
@sqlstr nvarchar(4000), --查询字符串
@currentpage int, --第N页
@pagesize int --每页行数
as
set nocount on
declare @P1 int, --P1是游标的id
@rowcount int
exec sp_cursoropen @P1 
output,@sqlstr,@scrollopt=1,@ccopt=1,@rowcount=@rowcount output
select ceiling(1.0*@rowcount/@pagesize) as 总页数--,@rowcount as 
总行数,@currentpage as 当前页
set @currentpage=(@currentpage-1)*@pagesize+1
exec sp_cursorfetch @P1,16,@currentpage,@pagesize
exec sp_cursorclose @P1
set nocount off
 


 
其它的方案：如果没有主键，可以用临时表，也可以用方案三做，但是效率会低。
建议优化的时候，加上主键和索引，查询效率会提高。
通过SQL 查询分析器，显示比较：结论是:
分页方案二：(利用ID大于多少和SELECT TOP分页）效率最高，需要拼接SQL语句
分页方案一：(利用Not In和SELECT TOP分页) 效率次之，需要拼接SQL语句
分页方案三：(利用SQL的游标存储过程分页) 效率最差，但是最为通用
在实际情况中，要具体分析。 
