Title: 学习：java原理—反射机制
Date: 1970-01-01 00:00:00
Modified: 1970-01-01 00:00:00
cat: java
Tags: 
Slug: 3832
Authors: u0mo5 
Summary: 

 
 

一、什么是反射：反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。这一概念的提 出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。其中 LEAD/LEAD++ 、OpenC++ 、MetaXa和OpenJava等就是基于反射机制的语言。最近，反射机制也被应用到了视窗系统、操作系统和文件系统中。反射本身并不 是一个新概念，尽管计算机科学赋予了反射概念新的含义。在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机 制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用 所描述行为的状态和相关的语义。二、什么是Java中的类反射：Reflection 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性和方法。Java 的这一能力在实际应用中用得不是很多，但是在其它的程序设计语言中根本就不存在这一特性。例如，Pascal、C 或者 C++ 中就没有办法在程序中获得函数定义相关的信息。Reflection 是 Java 被视为动态（或准动态）语言的关键，允许程序于执行期 Reflection APIs 取得任何已知名称之 class 的內部信息，包括 package、type parameters、superclass、implemented interfaces、inner classes, outer class, fields、constructors、methods、modifiers，並可于执行期生成instances、变更 fields 內容或唤起 methods。三、Java类反射中所必须的类：Java的类反射所需要的类并不多，它们分别是：Field、Constructor、Method、Class、Object，下面我将对这些类做一个简单的说明。Field类：提供有关类或接口的属性的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）属性或实例属性，简单的理解可以把它看成一个封装反射类的属性的类。Constructor类：提供关于类的单个构造方法的信息以及对它的访问权限。这个类和Field类不同，Field类封装了反射类的属性，而Constructor类则封装了反射类的构造方法。Method类：提供关于类或接口上单独某个方法的信息。所反映的方法可能是类方法或实例方法（包括抽象方法）。 这个类不难理解，它是用来封装反射类方法的一个类。Class类：类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。Object类：每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法。四、Java的反射类能做什么：看完上面的这么多我想你已经不耐烦了，你以为我在浪费你的时间，那么好吧！下面我们就用一些简单的小例子来说明它。首先我们来看一下通过Java的反射机制我们能得到些什么。首先我们来写一个类：java 代码

import java.awt.event.ActionListener;  
import java.awt.event.ActionEvent;  
class A extends Object implements ActionListener{  
private int a = 3;  
public Integer b = new Integer(4);  
public A(){}  
public A(int id,String name){}  
public int abc(int id,String name){return 0;}  
public void actionPerformed(ActionEvent e){}  
}  



你可能被我这个类弄糊涂了，你看不出我要做什么，那就不要看这个类了，这个类是用来测试的，你知道知道它继承了Object类，有一个接口是ActionListener，两个属性int和Integer,两个构造方法和两个方法，这就足够了。下面我们把A这个类作为一个反射类，来过去A类中的一些信息，首先我们先来过去一下反射类中的属性和属性值。java 代码

import java.lang.reflect.*;  
class B{  
public static void main(String args[]){  
A r = new A();  

Class temp = r.getClass();  
try{  
System.out.println("反射类中所有公有的属性");  

Field[] fb =temp.getFields();  
for(int j=0;j&lt;fb.length;j++){  
Class cl = fb[j].getType();  
System.out.println("fb:"+cl);  

}  
  
System.out.println("反射类中所有的属性");  

Field[] fa = temp.getDeclaredFields();  
for(int j=0;j&lt;fa.length;j++){  
Class cl = fa[j].getType();  
System.out.println("fa:"+cl);  

}  
System.out.println("反射类中私有属性的值");  

Field f = temp.getDeclaredField("a");  

f.setAccessible(true);  

Integer i = (Integer)f.get(r);  
System.out.println(i);  
}catch(Exception e){  

e.printStackTrace();  
}  
}  
  
}   



这 里用到了两个方法，getFields()、getDeclaredFields()，它们分别是用来获取反射类中所有公有属性和反射类中所有的属性的方 法。另外还有getField(String)和getDeclaredField(String)方法都是用来过去反射类中指定的属性的方法，要注意的 是getField方法只能取到反射类中公有的属性，而getDeclaredField方法都能取到。这里还用到了Field 类的setAccessible方法，它是用来设置是否有权限访问反射类中的私有属性的，只有设置为true时才可以访问，默认为false。另外 Field类还有set(Object AttributeName,Object value)方法，可以改变指定属性的值。下面我们来看一下如何获取反射类中的构造方法java 代码

import java.lang.reflect.*;  
public class SampleConstructor {  
public static void main(String[] args) {  
A r = new A();  

printConstructors(r);  
}  
  
public static void printConstructors(A r) {  
Class c = r.getClass();  
//获取指定类的类名  
String className = c.getName();  
try {  
//获取指定类的构造方法  
Constructor[] theConstructors = c.getConstructors();  
for(int i=0; i&lt;theConstructors.length; i++) {  
//获取指定构造方法的参数的集合  
Class[] parameterTypes = theConstructors[i].getParameterTypes();  
  
System.out.print(className + "(");  

  
for(int j=0; j&lt;parameterTypes.length; j++)  
System.out.print(parameterTypes[j].getName() + " ");  

  
System.out.println(")");  

  
}  
}catch(Exception e) {  

e.printStackTrace();  
}  
}  
}  



这个例子很简单,只是用getConstructors()方法获取了反射类的构造方法的集合，并用Constructor类的getParameterTypes()获取该构造方法的参数。下面我们再来获取一下反射类的父类（超类）和接口java 代码

import java.io.*;  
import java.lang.reflect.*;  
  
public class SampleInterface {  
public static void main(String[] args) throws Exception {  
A raf = new A();  

printInterfaceNames(raf);  
}  
  
public static void printInterfaceNames(Object o) {  
Class c = o.getClass();  
//获取反射类的接口  
Class[] theInterfaces = c.getInterfaces();  
for(int i=0; i&lt;theInterfaces.length; i++)  
System.out.println(theInterfaces[i].getName());  
//获取反射类的父类（超类）  
Class theSuperclass = c.getSuperclass();  
System.out.println(theSuperclass.getName());  
}  
}  



这 个例子也很简单，只是用Class类的getInterfaces()方法获取反射类的所有接口，由于接口可以有多个，所以它返回一个 Class数组。用getSuperclass()方法来获取反射类的父类（超类），由于一个类只能继承自一个类，所以它返回一个Class对象。下面我们来获取一下反射类的方法java 代码

import java.lang.reflect.*;  
public class SampleMethod {  
  
public static void main(String[] args) {  
A p = new A();  

printMethods(p);  
}  
  
public static void printMethods(Object o) {  
Class c = o.getClass();  
String className = c.getName();  
Method[] m = c.getMethods();  
for(int i=0; i&lt;m.length; i++) {  
//输出方法的返回类型  
System.out.print(m[i].getReturnType().getName());  
//输出方法名  
System.out.print(" "+m[i].getName()+"(");  

//获取方法的参数  
Class[] parameterTypes = m[i].getParameterTypes();  
for(int j=0; j&lt;parameterTypes.length; j++){  
System.out.print(parameterTypes[j].getName());  
if(parameterTypes.length&gt;j+1){  
System.out.print(",");  

}  
}  
  
System.out.println(")");  

}  
  
}  
  
}  



这个例子并不难，它只是获得了反射类的所有方法，包括继承自它父类的方法。然后获取方法的返回类型、方法名和方法参数。接下来让我们回过头来想一想，我们获取了反射类的属性、构造方法、父类、接口和方法，可这些东西能帮我们做些什么呢！！下面我写一个比较完整的小例子，来说明Java的反射类能做些什么吧！！java 代码

import java.lang.reflect.Constructor;  
import java.lang.reflect.Method;  
  
public class LoadMethod {  
public Object Load(String cName,String MethodName,String[] type,String[] param){  
Object retobj = null;  

try {  
//加载指定的Java类  
Class cls = Class.forName(cName);  
  
//获取指定对象的实例  
Constructor ct = cls.getConstructor(null);  

Object obj = ct.newInstance(null);  

  
//构建方法参数的数据类型  
Class partypes[] = this.getMethodClass(type);  

  
//在指定类中获取指定的方法  
Method meth = cls.getMethod(MethodName, partypes);  
  
//构建方法的参数值  
Object arglist[] = this.getMethodObject(type,param);  

  
//调用指定的方法并获取返回值为Object类型  
retobj= meth.invoke(obj, arglist);  
  
}  
catch (Throwable e) {  
System.err.println(e);  
}  
return retobj;  
}  
  
//获取参数类型Class[]的方法  
public Class[] getMethodClass(String[] type){  
Class[] cs = new Class[type.length];  

for (int i = 0; i &lt; cs.length; i++) {  
if(!type[i].trim().equals("")||type[i]!=null){  
if(type[i].equals("int")||type[i].equals("Integer")){  
cs[i]=Integer.TYPE;  
}else if(type[i].equals("float")||type[i].equals("Float")){  

cs[i]=Float.TYPE;  
}else if(type[i].equals("double")||type[i].equals("Double")){  

cs[i]=Double.TYPE;  
}else if(type[i].equals("boolean")||type[i].equals("Boolean")){  

cs[i]=Boolean.TYPE;  
}else{  

cs[i]=String.class;  

}  
}  
}  
return cs;  
}  
  
//获取参数Object[]的方法  
public Object[] getMethodObject(String[] type,String[] param){  
Object[] obj = new Object[param.length];  

for (int i = 0; i &lt; obj.length; i++) {  
if(!param[i].trim().equals("")||param[i]!=null){  
if(type[i].equals("int")||type[i].equals("Integer")){  
obj[i]= new Integer(param[i]);  

}else if(type[i].equals("float")||type[i].equals("Float")){  

obj[i]= new Float(param[i]);  

}else if(type[i].equals("double")||type[i].equals("Double")){  

obj[i]= new Double(param[i]);  

}else if(type[i].equals("boolean")||type[i].equals("Boolean")){  

obj[i]=new Boolean(param[i]);  

}else{  

obj[i] = param[i];  
}  
}  
}  
return obj;  
}  
}  



这是我在工作中写的一个实现Java在运行时加载指定的类，并调用指定方法的一个小例子。这里没有main方法，你可以自己写一个。Load方法接收的五个参数分别是，Java的类名，方法名，参数的类型和参数的值。结束语：Java 语言反射提供一种动态链接程序组件的多功能方法。它允许程序创建和控制任何类的对象，无需提前硬编码目标类。这些特性使得反射特别适用于创建以非常普通的 方式与对象协作的库。Java reflection 非常有用，它使类和数据结构能按名称动态检索相关信息，并允许在运行着的程序中操作这些信息。Java 的这一特性非常强大，并且是其它一些常用语言，如 C、C++、Fortran 或者 Pascal 等都不具备的。但反射有两个缺点。第一个是性能问题。用于字段和方法接入时反射要远 慢于直接代码。性能问题的程度取决于程序中是如何使用反射的。如果它作为程序运行中相对很少涉及的部分，缓慢的性能将不会是一个问题。即使测试中最坏情况 下的计时图显示的反射操作只耗用几微秒。仅反射在性能关键的应用的核心逻辑中使用时性能问题才变得至关重要。
 

分类: Java原





