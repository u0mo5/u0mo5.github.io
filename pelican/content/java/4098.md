Title: ios_常用关键字
Date: 1970-01-01 00:00:00
Modified: 1970-01-01 00:00:00
cat: default
Tags: 
Slug: 4098
Authors: u0mo5 
Summary: 

一、关键字说明 1. @synthesize关键字:  根据@property设置，自动生成成员变量相应的存取方法，从而可以使用点操作符来方便的存取该成员变量 。 2. @implementation 关键字： 表明类的实现 @end 结束 3. self 关键字： 类似于java中的this，是隐藏参数，指向当前调用方法的类。 4. super 关键字： 调用父类的方法。self = [superinit]  这里不是判断self与[superinit]是否相等，而是判断是否可以成功初始化。[super init]：父类初始化成功的话，通过=给self，这样self成为一个非空对象，整个来说即非false(非NO)。 5. #import关键字： 告诉预处理器,将头文件的内容包含到本文件的. OC 中，import 能保证头文件只会被包含一次 。 6. @interface关键字： 声明一个xxx类。@end 结束声明.  7. 冒号： 表示继承 后面跟的是父类.   8. @property关键字： 设置成员变量的属性（有读／写，赋值assign,retain,copy ,以及对多线程的支持nonatomic）。  二、方法的申明 1. 声明一个方法，格式是 ： –(返回值) 方法关键字1 : (参数类型)参数名 方法关键字2 : (参数类型)参数名 …… （在读方法的时候就可以先找方法关键字来确定参数）。 2. 减号是实例方法， + 是类方法 3. 另一个初始化方法中调用已有的初始化方法  这种概念被称为Designated Initializer.  三、输出流 NSLog是OC中的标准输出, 附加输出当时日期, 时间, 应用程序名称 . 使用NSLog()输出任意对象的值时,都会使用%@格式说明。在使用这个说明符时,对象通过一个名为description的方法提供自己的NSLog()格式。   四、getter/setter方法 对象.属性：使用@property配合@synthesize可以让编译器自动实现getter/setter方法，使用的时候也很方便，可以直接使用“对象.属性”的方法调用; 对象.方法：如果我们想要”对象.方法“的方式来调用一个方法并获取到方法的返回值，那就需要使用@property配合@dynamic了。使用@dynamic关键字是告诉编译器由我们自己来实现访问方法。如果使用的是@synthesize，那么这个工作编译器就会帮你实现了。  
 
 
 
 
 
五、属性的设置 1. readonly此标记说明属性是只读的，默认的标记是读写，如果你指定了只读，在@implementation中只需要一个读取器。或者如果你使用@synthesize关键字，也是有读取器方法被解析。而且如果你试图使用点操作符为属性赋值，你将得到一个编译错误。 2. readwrite此标记说明属性会被当成读写的，这也是默认属性。设置器和读取器都需要在@implementation中实现。如果使用@synthesize关键字，读取器和设置器都会被解析。 3. nonatomic：非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能。如果不加此属性，则默认是两个访问方法都为原子型事务访问。 4. atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。atomic设置成员变量的@property属性时，默认为atomic，提供多线程安全。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果。加了atomic，setter函数会变成下面这样：             {lock}             if (property != newValue) {                [property release];                property = [newValue retain];              }             {unlock} nonatomic禁止多线程，变量保护，提高性能。atomic是Objc使用的一种线程保护技术，基本上来讲，是防止在写未完成的时候被另外一个线程读取，造成数据错误。而这种机制是耗费系统资源的，所以在iPhone这种小型设备上，如果没有使用多线程间的通讯编程，那么nonatomic是一个非常好的选择。 指出访问器不是原子操作，而默认地，访问器是原子操作。这也就是说，在多线程环境下，解析的访问器提供一个对属性的安全访问，从获取器得到的返回值或者通过设置器设置的值可以一次完成，即便是别的线程也正在对其进行访问。如果你不指定 nonatomic ，在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值。 5. assign: 简单赋值，不更改索引计数，适用于基础数据类型 （例如NSInteger，CGFloat）和C数据类型（int, float, double, char, 等）等简单数据类型 此标记说明设置器直接进行赋值，这也是默认值。在使用垃圾收集的应用程序中，如果你要一个属性使用assign，且这个类符合NSCopying协议，你就要明确指出这个标记，而不是简单地使用默认值，否则的话，你将得到一个编译警告。这再次向编译器说明你确实需要赋值，即使它是可拷贝的。 6. copy:建立一个索引计数为1的对象，然后释放旧对象，对NSString 它指出，在赋值时使用传入值的一份拷贝。拷贝工作由copy方法执行，此属性只对那些实行了NSCopying协议的对象类型有效。 7. retain:释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1，对其他NSObject和其子类，对参数进行release旧值，再retain新值，指定retain会在赋值时唤醒传入值的retain消息。此属性只能用于Objective-C对象类型，而不能用于Core Foundation对象。(原因很明显，retain会增加对象的引用计数，而基本数据类型或者Core Foundation对象都没有引用计数——译者注)。         注意: 把对象添加到数组中时，引用计数将增加对象的引用次数+1。 
 
 
 
 
              retain的实际语法为：               - (void)setName:(NSString *)newName {                      if (name != newName) {                         [name release];                         name = [newName retain];                         // name’s retain count has been bumped up by 1                     }                 } 8. copy与retain： 1) Copy其实是建立了一个相同的对象，而retain不是： 比如一个NSString对象，地址为0×1111，内容为@”STR”，Copy到另外一个NSString之后，地址为0×2222，内容相同，新的对象retain为1，旧有对象没有变化，retain到另外一个NSString之后，地址相同（建立一个指针，指针拷贝），内容当然相同，这个对象的retain值+1也就是说，retain是指针拷贝，copy是内容拷贝。 2) retain的set方法应该是浅复制，copy的set方法应该是深复制了 3) copy另一个用法： copy是内容的拷贝,对于像NSString,的确是这样.但是,如果是copy的是一个NSArray呢?比如： NSArray *array = [NSArray arrayWithObjects:@"hello",@"world",@"baby"]; NSArray *array2 = [array copy];  这个时候,,系统的确是为array2开辟了一块内存空间,但是我们要认识到的是,array2中的每个元素,只是copy了指向array中相对应元素的指针.这便是所谓的"浅复制". 9. assign与retain： 1) 接触过C，那么假设你用malloc分配了一块内存，并且把它的地址赋值给了指针a，后来你希望指针b也共享这块内存，于是你又把a赋值给（assign）了b。此时a和b指向同一块内存，请问当a不再需要这块内存，能否直接释放它？答案是否定的，因为a并不知道b是否还在使用这块内存，如果a释放了，那么b在使用这块内存的时候会引起程序crash掉。 2) 了解到1)中assign的问题，那么如何解决？最简单的一个方法就是使用引用计数（reference counting），还是上面的那个例子，我们给那块内存设一个引用计数，当内存被分配并且赋值给a时，引用计数是1。当把a赋值给b时引用计数增加到2。这时如果a不再使用这块内存，它只需要把引用计数减1，表明自己不再拥有这块内存。b不再使用这块内存时也把引用计数减1。当引用计数变为0的时候，代表该内存不再被任何指针所引用，系统可以把它直接释放掉。 总结：上面两点其实就是assign和retain的区别，assign就是直接赋值，从而可能引起1)中的问题，当数据为int, float等原生类型时，可以使用assign。retain就如2)中所述，使用了引用计数，retain引起引用计数加1, release引起引用计数减1，当引用计数为0时，dealloc函数被调用，内存被回收。  六、具体解析assign，retain，copy NSString *pt = [[NSString alloc] initWithString:@"abc"]; 
 
 
 
 
上面一段代码会执行以下两个动作 a 在堆上分配一段内存用来存储@"abc"  比如：内存地址为：0X1111 内容为 "abc b 在栈上分配一段内存用来存储pt  比如：地址为：0Xaaaa 内容自然为0X1111   下面分别看下assign   retain   copy assign的情况： NSString *newPt = [pt assign]; 此时newPt和pt完全相同，地址都是0Xaaaa ，内容为0X1111 ，即newPt只是pt的别名，对任何一个操作就等于对另一个操作。 因此retainCount不需要增加。 retain的情况： NSString *newPt = [pt retain];  此时newPt的地址不再为0Xaaaa，可能为0Xaabb 但是内容依然为0X1111。 因此newPt 和 pt 都可以管理"abc"所在的内存。因此 retainCount需要增加1   copy的情况： NSString *newPt = [pt copy]; 此时会在堆上重新开辟一段内存存放@"abc" 比如0X1122 内容为@"abc 同时会在栈上为newPt分配空间 比如地址：0Xaacc 内容为0X1122 因此retainCount增加1供newPt来管理0X1122这段内存  //—————————————————————————— 看了这么多也许大家有点晕， 现在进行实际的代码演示： @property (nonatomic, assign) int number; 这里定义了一个int类型的属性， 那么这个int是简单数据类型，本身可以认为就是原子访问，所以用nonatomic,不需要进行引用计数，所以用assign。适用于所有简单数据类型。 @property (nonatomic, copy) NSString * myString; 这里定义了一个NSString类型的属性，不需要原子操作，所以用nonatomic。为什么需要copy，而不是retain呢！ 因为如果对myString赋值原字符串是一个可变的字符串(NSMutableString)对象的话，用retain的话，当原字符串改变的时候你的myString属性也会跟着变掉。我想你不希望看到这个现象。 实际上测试，如果原来的字符串是NSString的话，也只是retain一下，并不会copy副本 @property (nonatomic, retain) UIView * myView; 这里定义了一个UIView类型的属性，不需要原子操作，所以用nonatomic。当对myView 赋值的时候原来的UIView对象retainCount会加1  //接口文件 @interface MyClass : NSObject  @property (nonatomic, assign)   int  number;  @property (nonatomic, copy)    NSString  * myString;  @property (nonatomic, retain)   UIView  * myView;  @end  //实现文件 @implementation MyClass  @synthesize number = _number;  @synthesize myString = _myString; 
 
