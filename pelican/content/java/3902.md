Title: 有关《查找两个List中的不同元素》的问题解答与编程实践
Date: 1970-01-01 00:00:00
Modified: 1970-01-01 00:00:00
cat: default
Tags: 
Slug: 3902
Authors: u0mo5 
Summary: 

 
 郑海波 2013-07-08

问题：
有List&lt;String&gt; list1和List&lt;String&gt; list2,两个集合各有上万个元素，怎样查找两个集合中不同的元素呢?
问题分析：
由于每个list中都有上万个元素，如果用简单的遍历查找算法，那么至少需要10000*10000次判断比较。显然，这样做的效率极低。那么有没有比较好的方案呢？经过我的思考，想出了2个办法。请大家评判。
方法一：遍历算法的改进算法
思路：对每一个list1中的元素，都在list2中查找一下，是否重复，如果不重复，则将该元素放到listDiff中。如果重复，则将该元素从list2中剔除。这样，能够减少遍历算法的时间复杂度，而且重复元素越多，该改进算法的运行时间就越短。当然，如果两个list的重复元素个数远远小于list的长度，则该算法的时间复杂度和遍历算法近似相同，会变的很慢而不切实际。
方法二：利用Map中无重复元素的特性
思路：将list1中元素首先复制到map&lt;String,Integer&gt;中,并将其Integer的值设置为1.然后再对list2中的元素，与map中元素比较。如果map中已经存在该String，那么map中对应String的Integer加1（表示字符串出现的次数），如果map中不存在，那么就将其复制到map中，并设置其Integer为1.那么，map中Integer值为1的元素所对应的String，就是两个list中不同的元素。
以下代码是在Java中实现，也可以用C++ STL进行测试。
 



[java] view plaincopy
 



import java.util.ArrayList;  
import java.util.HashMap;  
import java.util.List;  
import java.util.Map;  
/*  
 *@author: ZhengHaibo     
 *2013-07-08  Nanjing,Conris,China  
 */   
public class TestMian {  
    private static final int ListLen = 10000;// 设置list的长度  

    private static final Integer flagUnique = 1;//无重复字符串的键值  

    public List&lt;String&gt; list1 = new ArrayList&lt;String&gt;();  

    public List&lt;String&gt; list2 = new ArrayList&lt;String&gt;();  

  
    public static void main(String[] args) {  

        // TODO Auto-generated method stub  

        TestMian mTest=new TestMian();  

        mTest.initList();  
        List&lt;String&gt; listDiff1=mTest.getDiffElementUseEach(mTest.list1,mTest.list2);//获得不同元素  

        mTest.initList();  
        List&lt;String&gt; listDiff2=mTest.getDiffElementUseMap(mTest.list1,mTest.list2);//获得不同元素  

        System.out.println("The number of diff element is: "+listDiff1.size());  

        System.out.println("The number of diff element is: "+listDiff2.size());  

        //mTest.printList(listDiff1);  

        //mTest.printList(listDiff2);  

    }  
    // 初始化list中的元素，并保证有相同的元素  

    public void initList() {  

        list1.clear();  
        list2.clear();  
        for (int i = 0; i &lt; ListLen; i++) {  

            list1.add("conris_list_of" + i + "test");  

            list2.add("conris_list_of" + 3 * i + "test");  

        }  
    }  
    //获得连个list中的不同元素，查找删除法  

    public List&lt;String&gt; getDiffElementUseEach(List&lt;String&gt; list1,List&lt;String&gt; list2) {  

        System.out.println("-----------------------方法1----------------------");  

        long runtime = System.nanoTime();// 开始计时  

        List&lt;String&gt; diffList = new ArrayList&lt;String&gt;();// 用于保存两个list中不同的元素  

        for (String string:list1) {//消除list1本身的重复元素  

            int index=list2.indexOf(string);  

            if (index==-1) {//说明list2中不存在此元素  

                diffList.add(string);  
            }else{//list2存在此元素，那么删除此元素  

                list2.remove(index);  
            }  
        }  
        for(String string:list2){//此时，liat2中的重复元素已经删除了，只需要复制到diffList中即可  

            diffList.add(string);  
        }  
        System.out.println("getDiffElementUseRemove run time:"  

                + (System.nanoTime() - runtime));  
        return diffList;  

    }  
    //获得两个list中的不同元素，map方法  

    public List&lt;String&gt; getDiffElementUseMap(List&lt;String&gt; list1,List&lt;String&gt; list2){  

        System.out.println("-----------------------方法2----------------------");  

        long runtime = System.nanoTime();//开始计时  

        //利用map中不能有重复元素的特点  

        Map&lt;String, Integer&gt; map = new HashMap&lt;String,Integer&gt;(list1.size()+ list2.size());  

        List&lt;String&gt; diffList = new ArrayList&lt;String&gt;();//用于保存两个list中不同的元素  

        for (String string : list1) {  

            map.put(string,flagUnique);//先将list1中元素复制到map中保存  

        }  
        for (String string : list2) {  

            Integer key = map.get(string);// 获得键值  

            if (key != null) {//如果map中已经存在该元素，说明list1中存在该元素，那么将其key加1  

                map.put(string, ++key);  
                continue;  

            }else{//如果不存在，则放入map中  

                map.put(string,flagUnique);  
            }  
        }  
        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()){  

            if (entry.getValue() == flagUnique)//在map中，键值为flagUnique的元素即为无重复的元素  

            {  
                diffList.add(entry.getKey());  
            }  
        }  
        System.out.println("getDiffElementUseMap run time:"  

                + (System.nanoTime() - runtime));  
        return diffList;  

    }  
    public void printList(List&lt;String&gt; list){  

        for(int i=0;i&lt;list.size();i++){  

            System.out.println(list.get(i));  
        }  
    }  
}  


 
实验结果：
当ListLen设置为10000时：
结果1：
 



[html] view plaincopy
 





-----------------------方法1----------------------  
getDiffElementUseRemove run time:2015792051  
-----------------------方法2----------------------  
getDiffElementUseMap run time:37966034  
The number of diff element is: 13332  
The number of diff element is: 13332  




当ListLen设置为100000时：等了半天方法1没有运行出来结果，方法2的运行结果如下： 
 



[html] view plaincopy
 





-----------------------方法2----------------------  
getDiffElementUseMap run time:471017640  
The number of diff element is: 133332  




 
可见当数据量达到100000时（增大10倍），方法二仍然可以工作，而且时间也随着数据量增大线性增加。
而方法1很久也没有运行出来结果…
由此可见，利用HashMap的方法速度更快，能够满足基本要求。不知道大家还有哪些想法可以交流交流。希望对大家有帮助。
PS：如果用C++ STL实现的话，运行速度将更快！没事的时候再试试~~
 


