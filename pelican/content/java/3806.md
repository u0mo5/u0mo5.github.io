Title: JAVA实现单例模式的四种方法和一些特点
Date: 1970-01-01 00:00:00
Modified: 1970-01-01 00:00:00
cat: java
Tags: 
Slug: 3806
Authors: u0mo5 
Summary: 

JAVA实现单例模式的四种方法和一些特点，需要的朋友可以参考一下
 
 


一、饿汉式单例类
 

复制代码 代码如下:

public class Singleton  {      
private Singleton(){      }      private static Singleton 
instance = new Singleton();      private static Singleton 
getInstance(){          return instance;      }  } 
 
 


 
特点：饿汉式提前实例化，没有懒汉式中多线程问题，但不管我们是不是调用getInstance()都会存在一个实例在内存中
二、内部类式单例类
 

复制代码 
代码如下:

public class Singleton     {        
        private Singleton(){         }         private class 
SingletonHoledr(){             private static Singleton instance = new 
Singleton();         }         private static Singleton 
getInstance(){             return SingletonHoledr.instance;         
}     } 
 
特点：内部类式中，实现了延迟加载，只有我们调用了getInstance(),才会创建唯一的实例到内存中.并且也解决了懒汉式中多线程的问题.解决的方式是利用了Classloader的特性. 

三、懒汉式单例类
 

复制代码 
代码如下:

public class Singleton     {        
    private Singleton(){         }         private static 
Singleton instance;         public static Singleton getInstance(){     
        if(instance == null){                 return instance = new 
Singleton();             }else{                 return instance;     
        }         }     }   
 
特点：在懒汉式中，有线程A和B，当线程A运行到第8行时，跳到线程B，当B也运行到8行时，两个线程的instance都为空，这样就会生成两个实例。解决的办法是同步：
可以同步但是效率不高：
 

复制代码 
代码如下:

public class Singleton     {        
    private Singleton(){         }         private static 
Singleton instance;         public static synchronized Singleton 
getInstance(){             if(instance == null){                 return 
instance = new Singleton();             }else{                 return 
instance;             }         }     } 
 
这样写程序不会出错，因为整个getInstance是一个整体的"critical 
section"，但就是效率很不好，因为我们的目的其实只是在第一个初始化instance的时候需要locking(加锁)，而后面取用instance的时候，根本不需要线程同步。 

于是聪明的人们想出了下面的做法：
双检锁写法： 
 

复制代码 
代码如下:

public class Singleton{    private 
static Singleton single;    //声明静态的单例对象的变量    private Singleton(){}    
//私有构造方法     public static Singleton getSingle(){    //外部通过此方法可以获取对象    
    if(single == null){             synchronized (Singleton.class) {   
//保证了同一时间只能只能有一个对象访问此同步块                    if(single == null){      
                single = new Singleton();                  }     
      }      }        return single;   //返回创建好的对象     }  } 
 
 


 
思路很简单，就是我们只需要同步（synchronize）初始化instance的那部分代码从而使代码既正确又很有效率。 
这就是所谓的“双检锁”机制（顾名思义）。 很可惜，这样的写法在很多平台和优化编译器上是错误的。 
原因在于：instance = new Singleton()这行代码在不同编译器上的行为是无法预知的。一个优化编译器可以合法地如下实现instance 
= new Singleton(): 
1. instance  = 给新的实体分配内存 
2. 调用Singleton的构造函数来初始化instance的成员变量 
现在想象一下有线程A和B在调用getInstance，线程A先进入，在执行到步骤1的时候被踢出了cpu。然后线程B进入，B看到的是instance  
已经不是null了（内存已经分配），于是它开始放心地使用instance，但这个是错误的，因为在这一时刻，instance的成员变量还都是缺省值，A还没有来得及执行步骤2来完成instance的初始化。 

当然编译器也可以这样实现： 
1. temp = 分配内存 
2. 调用temp的构造函数 
3. instance = temp 
如果编译器的行为是这样的话我们似乎就没有问题了，但事实却不是那么简单，因为我们无法知道某个编译器具体是怎么做的，因为在Java的memory 
model里对这个问题没有定义。 
双检锁对于基础类型（比如int）适用。很显然吧，因为基础类型没有调用构造函数这一步。


