Title: JAVA设计模式之单例模式
Date: 1970-01-01 00:00:00
Modified: 1970-01-01 00:00:00
cat: java
Tags: 
Slug: 3849
Authors: u0mo5 
Summary: 


概念：
　　java中单例模式是一种常见的设计模式，单例模式分三种：懒汉式单例、饿汉式单例、登记式单例三种。
　　单例模式有一下特点：
　　1、单例类只能有一个实例。
　　2、单例类必须自己自己创建自己的唯一实例。
　　3、单例类必须给所有其他对象提供这一实例。　
　单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序
对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer
 
Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请
求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。
首先看一个经典的单例实现。



[java] view plaincopyprint?




public class Singleton {  
    private static Singleton uniqueInstance = null;  

   
    private Singleton() {  

       // Exists only to defeat instantiation.  

    }  
   
    public static Singleton getInstance() {  

       if (uniqueInstance == null) {  

           uniqueInstance = new Singleton();  

       }  
       return uniqueInstance;  

    }  
    // Other methods...  

}  




 
Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围
内，Singleton的唯一实例只能通过getInstance()方法访问。（事实上，通过Java反射机制是能够实例化构造方法为private的
类的，那基本上会使所有的Java单例实现失效。此问题在此处不做讨论，姑且掩耳盗铃地认为反射机制不存在。）
但是以上实现没有考虑线程安全问题。所谓线程安全是指：如果你的代码所在的进程中有多个线程在同时运
行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。或者说：
一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。显然以
上实现并不满足线程安全的要求，在并发环境下很可能出现多个Singleton实例。
 



[java] view plaincopyprint?




package jason.single;  
  
public class TestStream {  
    String name = null;  

  
    public String getName() {  

        return name;  

    }  
  
    public void setName(String name) {  

        this.name = name;  

    }  
  
    private TestStream() {  

    }  
  
    private static TestStream ts1 = null;  

  
    public static TestStream getTest() {  

        if (ts1 == null) {  

            ts1 = new TestStream();  

        }  
        return ts1;  

    }  
  
    public void printInfo() {  

        System.out.println("the name is " + name);  

    }  
  
}  




 



[java] view plaincopyprint?




package jason.single;  
  
public class TMain {  
    public static void main(String[] args){  

        TestStream ts1 = TestStream.getTest();  
        ts1.setName("jason");  

        TestStream ts2 = TestStream.getTest();  
        ts2.setName("0539");  

          
        ts1.printInfo();  
        ts2.printInfo();  
          
        if(ts1 == ts2){  

            System.out.println("创建的是同一个实例");  

        }else{  

            System.out.println("创建的不是同一个实例");  

        }  
    }  
}  



 
运行结果：

结论：由结果可以得知单例模式为一个面向对象的应用程序提供了对象惟一的访问点，不管它实现何种功能，整个应用程序都会同享一个实例对象。
 
1.饿汉式单例类



[java] view plaincopyprint?




//饿汉式单例类.在类初始化时，已经自行实例化   
public class Singleton1 {  
    //私有的默认构造子  

    private Singleton1() {}  

    //已经自行实例化   

    private static final Singleton1 single = new Singleton1();  

    //静态工厂方法   

    public static Singleton1 getInstance() {  

        return single;  

    }  
}  




2.懒汉式单例类



[java] view plaincopyprint?




//懒汉式单例类.在第一次调用的时候实例化   
public class Singleton2 {  
    //私有的默认构造子  

    private Singleton2() {}  

    //注意，这里没有final      

    private static Singleton2 single=null;  

    //静态工厂方法   

    public synchronized  static Singleton2 getInstance() {  

         if (single == null) {    

             single = new Singleton2();  

         }    
        return single;  

    }  
}  




 



[java] view plaincopyprint?




import java.util.HashMap;  
import java.util.Map;  
//登记式单例类.  
//类似Spring里面的方法，将类名注册，下次从里面直接获取。  
public class Singleton3 {  
    private static Map&lt;String,Singleton3&gt; map = new HashMap&lt;String,Singleton3&gt;();  

    static{  

        Singleton3 single = new Singleton3();  

        map.put(single.getClass().getName(), single);  
    }  
    //保护的默认构造子  

    protected Singleton3(){}  

    //静态工厂方法,返还此类惟一的实例  

    public static Singleton3 getInstance(String name) {  

        if(name == null) {  

            name = Singleton3.class.getName();  

            System.out.println("name == null"+"---&gt;name="+name);  

        }  
        if(map.get(name) == null) {  

            try {  

                map.put(name, (Singleton3) Class.forName(name).newInstance());  
            } catch (InstantiationException e) {  

                e.printStackTrace();  
            } catch (IllegalAccessException e) {  

                e.printStackTrace();  
            } catch (ClassNotFoundException e) {  

                e.printStackTrace();  
            }  
        }  
        return map.get(name);  

    }  
    //一个示意性的商业方法  

    public String about() {      

        return "Hello, I am RegSingleton.";      

    }      
    public static void main(String[] args) {  

        Singleton3 single3 = Singleton3.getInstance(null);  

        System.out.println(single3.about());  
    }  
}  



 




